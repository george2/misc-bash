#!/bin/bash
# my version of the `bundle' shell script (similar to GNU shar). 
# create a self-extracting shell script that can install any file(s).
# Usage: bundle [OPTIONS] [FILES] > install_whatever.sh
ver="george's bundle 0.9.1"

#. getargs.sh  # I'm planning on centralizing and improving the stuff below, and making a script with argument-functions.

for arg in "$@"; do
  if [ -n "$argisu" -a "$argisu" == "1" ]; then
    uzipwith=$arg
    argisu=0
    arg=
  elif [ -n "$argisb" -a "$argisb" == "1" ]; then
    bundle=$arg
    argisb=0
    arg=
  fi
  if [ "$arg" == "--uzipwith" -o "$arg" == "-u" ]; then 
    argisu=1
  elif [ "$arg" == "--filesonly" -o "$arg" == "-f" -o "$arg" == "--basename" ]; then  # --basename provided for shar compatibility. 
    presdirs=0
  elif [ "$arg" == "--help" -o "$arg" == "-h" ]; then 
    $0
    exit 0
  elif [ "$arg" == "--version" -o "$arg" == "-v" ]; then 
    echo "$ver"
    exit 0
  elif [ "$arg" == "--norecurse" -o "$arg" == "-n" ]; then 
    recurse=0
  elif [ "$arg" == "--sha" -o "$arg" == "-s" ]; then 
    hashwith=sha1sum
  elif (echo "$arg" | grep -q '^--sha..*'); then 
    alg=$(echo "$arg" | sed 's/--sha//g')
    hashwith=$(echo "sha$alg sum" | sed 's/\s//g')
  elif (echo "$arg" | grep -q '^-s..*'); then 
    alg=$(echo "$arg" | sed 's/-s//g')
    hashwith=$(echo "sha$alg sum" | sed 's/\s//g')
  elif [ "$arg" == "--crypt" -o "$arg" == "-c" ]; then 
    crypt=1
    echo -n Password/phrase to use for encryption:\  >&2
    read pass
    key=$(echo "$pass" | sha512sum -b | base64 -w 0)
    echo Sorry, this feature is not yet ready.
    exit 1
  elif [ "$arg" == "--targz" -o "$arg" == "-z" -o "$arg" == "--gzip" -o "$arg" == "--gz" ]; then 
    uzipwith="tar -xzf"
    zipwith="tar -czf"
  elif [ "$arg" == "--tarbz" -o "$arg" == "-j" -o "$arg" == "--bzip" -o "$arg" == "--bz" ]; then 
    uzipwith="tar -xjf"
    zipwith="tar -cjf"
  elif [ "$arg" == "--tarxz" -o "$arg" == "-x" -o "$arg" == "--xzip" -o "$arg" == "--xz" ]; then 
    uzipwith="tar -xJf"
    xz=1
    zipwith="tar -cf"
  elif [ "$arg" == "--info" -o "$arg" == "-i" -o "$arg" == "-l" -o "$arg" == "--list" ]; then 
    stat=1
    argisb=1
  elif (echo "$arg" | grep -q '^-..*'); then 
    echo "$(basename $0): invalid option $arg" >&2
    exit 1
  elif [ "$arg" == "--uuencode" -o "$arg" == "-e" ]; then 
    encode=uuencode
    echo Sorry, this feature is not yet ready. >&2
    exit 1
  else
    files=`printf "$files\n$arg"`
  fi
done

if [ -z "$1" -o "$1" == "--help" -o "$1" == "-h" ]; then 
  echo "Usage: $(basename $0) [OPTIONS] [FILES] > install_whatever.sh" 
  echo "Options: " 
  echo "  -u, --uzipwith 'prog'	automatically unzip compressed files, with 'prog [OPT(S)]'" 
  echo "                  	The script will attempt to unzip all of its files, so" 
  echo "                	do not use this feature with any uncompressed files "
  echo "  -e, --uuencode 	* use uuencode instead of base64 to create archives"
  echo "  -f, --filesonly	don't preserve directory structure, just bundle files" 
  echo "  -l, --list 'bundle'	list files in a bundle, accepts '-' or file as arg" 
  echo "  -i, --info 'bundle'	* show info on files in a bundle, accepts '-' or file as arg" 
  echo "  -n, --norecurse	don't recurse subdirectories " 
  echo "  -sX, --shaX   	use shaXsum for file verification instead of $hashwith" 
  echo "                	The sha* option prefers shaXsum, but can use \`shasum -a X' as well" 
  echo "                	Example usage: --sha512, -s256. Both -s and -s1 will use sha1." 
  echo "  -c, --crypt   	* encrypt files, interactively asks for password" 
  echo "  -z, --targz   	compress files first with \`tar -czf', then bundle" 
  echo "  -j, --tarbz   	compress files first with \`tar -cjf', then bundle" 
  echo "  -x, --tarxz   	compress files first with \`tar -cf', then \`xz -ez9', then "
  echo "                	bundle. This achieves maximum compression, but takes longer." 
  echo "                	Files are extracted with \`tar -xJf'" 
  echo "  -b, --makebat 	* create Windoze batch files, instead of bash scripts- cannot " 
  echo "                	be used with other options, greatly reduced functionality." 
  echo "  -d, --delete  	delete original files"
  echo "  -v, --version 	print version information and exit" 
  echo "  -h, --help    	print this help and exit" 
  echo 
  echo "Note: Options with '*' are not yet implemented." 
  echo "Options CANNOT be specified like '-rzs', they must be like '-r -z -s'" 
  echo "The default function (no options) is simplest, and best for using when you do not" 
  echo "know what programs the person executing the bundle has installed. For best results" 
  echo "when creating bundles for your own use, the author recommends the options '-s -z'." 
  exit 0
fi

encode=${encode-base64}
if ! test -x "`which $encode`" ; then 
  echo "Sorry, no $encode executable was found." >&2
  echo "We need this in order to continue." >&2
  exit 1
fi


if [ "$stat" == "1" -a -n "$bundle" ]; then # since this uses grep, it supports - as stdin, so you can use eg. `bundle file | bundle -l -' to test bundle.
  echo "Files in $bundle:" >&2
  echo >&2
  grep 'file=' "$bundle" | sed 's/.*file=//' | sed 's/;\sfi//' | sed "s/'//g" | sed 's/"//g'
  echo >&2
  exit 0
fi


hashwith=${hashwith-md5sum}
if ! test -x "`which $hashwith`"; then
  if ! test -x "`which shasum`"; then
    echo "$hashwith cannot be found - exiting" >&2
    exit 1
  elif [ -n "$alg" ]; then
    if [ "$alg" == "1" -o "$alg" == "224" -o "$alg" == "256" -o "$alg" == "384" -o "$alg" == "512" -o "$alg" == "512224" -o "$alg" == "512256" ]; then 
      echo "$(basename $0): $hashwith cannot be found, using 'shasum -a $alg' instead" >&2
      echo "$(basename $0): This may cause problems; be warned!" >&2
      echo -n "$(basename $0): Continuing in 3... " >&2; sleep 1; echo -n "2... " >&2; sleep 1; echo -n "1... " >&2; sleep 1; echo "0" >&2
      hashwith="shasum -a $alg"
    else
      echo "$(basename $0): Invalid algorithm $alg, quitting" >&2
      exit 1
    fi
  else
    echo "$(basename $0): unknown error, \$alg empty!" >&2
    echo "$(basename $0): is the md5sum executable missing?" >&2
    exit 1
  fi
fi

if [ -n "$files" -o "$files" == " " ]; then 
  echo '#!/bin/bash'
  echo "# $ver self-extracting archive."
  echo "# Usage: \`thisscript', or \`thisscript /install/to/this/dir'"
  echo "if ! test -x \"\`which $encode\`\"; then echo Sorry, no $encode executable was found. >&2; echo We need this in order to continue. >&2; exit 1; fi"
  echo 'dir=${1-.}'
  echo "if test -d \"\$dir\"; then echo directory \'\$dir\' exists, starting extraction...; elif test -r \"\$dir\"; then echo \$dir is a file, but needs to be a folder; exit 1; else echo creating directory \'\$dir\' ...; mkdir -p \"\$dir\"; fi"
  if [ -n "$uzipwith" ]; then 
    echo "$(basename $0): this script will extract files with '$uzipwith'" >&2
    echo "$(basename $0): note that the person running the bundled script will need this program" >&2
    echo "# This script will use '$uzipwith' to extract files. You must have this program installed."
  fi
  echo "integerr=0"
else 
  echo "$(basename $0): No files specified, nothing to do." >&2
  exit 1
fi

if [ -n "$zipwith" ]; then
  echo "$(basename $0): Compressing files first with '$zipwith'... " >&2
  now=$(date +%s)
  tempar="/tmp/bundle-${BASHPID-0}.$now"
  $zipwith $tempar $files
  if [ -n "$xz" -a "$xz" == "1" ]; then
    echo "$(basename $0): Compressing files with 'xz -ez9'... " >&2
    xz -ez9 $tempar -c > $tempar.tar.xz
    rm $tempar
    tempar=$tempar.tar.xz
  fi
  files="$tempar"
  rmfiles=1
  presdirs=0
  echo "$(basename $0): Creating bundle..." >&2
fi

newline='
'
IFS="$newline"
if [ "$recurse" != "0" ]; then
  filesarr=($(find $files))
else 
  filesarr=($files)
fi
for file in "${filesarr[@]}"; do 
  if [ -z "$uzipwith" ]; then 
    uzipdo="# "
  else
    IFS=' '
    uzipdo="echo unzipping \$file with \'$uzipwith\'; owd=\"\$(pwd)\"; cd \"\$dir\"; $uzipwith \"./\$file\"; echo removing \$file ...; rm \"./\$file\"; cd \"\$owd\""
    IFS="$newline"
  fi
  if test -d "$file"; then
    echo "echo creating directory \$dir/$file"
    echo "mkdir -p \"\$dir/$file\""
    continue
  elif test -r "$file"; then
    fileperm="$(stat -c %a $file)"
    IFS=' '
    filesum=$($hashwith -b $file | awk '{printf $1}')
    IFS="$newline"
    filedir="$(dirname $file | sed 's@^/@@')"
    ofiledir="$(dirname $file)"
    filecont="$($encode -w 100 $file)"
    file="$(basename $file)"
  else
    echo "$(basename $0): $file does not exist or is not readable." >&2
  fi

  echo "# START FILE -- \`$filedir/$file\`"
  if [ -z "$presdirs" -o "$presdirs" != "0" ]; then 
    echo "if test -d \"\$dir/$filedir\"; then echo \"\$dir/$filedir\" exists ...; file='$filedir/$file'; elif test -r \"\$dir/$filedir\"; then echo \"\$dir/$filedir\" is a file, but needs to be a folder; exit 1; else echo creating \$dir/$filedir; mkdir -p \$dir/$filedir; file='$filedir/$file'; fi"
  else 
    echo "file=\"$file\""
  fi
  echo "echo extracting \$dir/\$file ..."
  echo "$encode -d << EOF > \"\$dir/\$file\""
  echo "$filecont"
  echo "EOF"
  echo "echo setting permissions on \$dir/\$file to $fileperm ..."
  echo "chmod $fileperm \"\$dir/\$file\""
  echo "echo -n checking \$dir/\$file file integrity \($hashwith\) ...\ "
  echo "filesum=\$($hashwith -b \"\$dir/\$file\" | awk '{printf \$1}')"
  echo "if [ \"\$filesum\" == \"$filesum\" ]; then echo looks like \$dir/\$file is ok.; else echo looks like \$dir/\$file is corrupted.; let integerr=\$integerr+1; fi"
  echo "$uzipdo"
  echo "# END FILE -- \`$filedir/$file\`"
  echo 
  if [ -n "$rmfiles" -a "$rmfiles" == "1" ]; then 
    rm $ofiledir/$file
  fi
done

echo "echo "
echo "echo Extraction complete."
echo "echo File verification errors: \$integerr "
